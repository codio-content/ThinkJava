workspace:
  directory: ThinkJava2
  tex: thinkjava.tex
  #removes inline code examples that are full programs (they auto-generate code files)
  removeTrinket: true
metadata:
  hideMenu: false
  protectLayout: false
  suppressPageNumbering: true
refs:
  #Offsets chapter numbering to match physical book
  chapter_counter_from: 0
assets:
  - code
  - figs: "*.png"
  - figs: "*.jpg"
  - trinket
sections:
  - name: Preface
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: The philosophy behind the book
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Object-oriented programming
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Changes to the 2nd edition
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: About the appendixes
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Using the code examples
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Contributors over the years
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
# Chapter 1
  - name: Computer programming
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: What is a computer?
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: What is programming?
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: The hello world program
    type: section
    transformations:
        - remove: 1
          position: 87
        - add:  |
             See the example java code in the top-left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Hello.java java -cp code/ Hello )
     
          position: 105
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Hello.java"
          panel: 0
          action: open
  - name: Compiling Java programs
    type: section
    transformations:
        - add:  |

              
              Try it out by typing `javac code/HelloWorld.java` into the terminal in the bottom-left pane and pressing Enter.
  
          position: 251
        - add:  |

              
              Try it out by typing `java -cp code/ HelloWorld` into the terminal in the bottom-left pane and pressing Enter.
  
          position: 264
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Hello.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Displaying two messages
    type: section
    transformations:
        - remove: 1
          position: 273
        - add: |


               For example, take a look at Hello2.java in the top-left pane which displays more than one line of output. To compile and run the code, press the "Run!"
               {Run!}(sh .guides/bg.sh javac code/Hello2.java java -cp code/ Hello2 )
       
          position: 274
        - remove: 1
          position: 301
        - add: |


               For example, take a look at Goodbye.java in the bottom-left pane which uses `print` instead of `println` to avoid the newling at the end. To compile and run the code, press the "Run!"
               {Run!}(sh .guides/bg.sh javac code/Goodbye.java java -cp code/ Goodbye )
       
          position: 302
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Hello2.java"
          panel: 0
          action: open
        - path: "code/Goodbye.java"
          panel: 1
          action: open
  - name: Formatting source code
    type: section
    transformations:
        - remove: 1
          position: 338
        - add: |
               For example, the program in the top-left pane, `Goodbye.java` *is* legal. To compile and run the code, press the "Run!"
               {Run!}(sh .guides/bg.sh javac code/1/Goodbye.java java -cp code/1/ Goodbye )
    
          position: 339
        - remove: 1
          position: 350
        - add: |
               For example, we could write the same program like the example `Goodbye.java` in the bottom-left pane. To compile and run the code, press the "Run!"
               {Run!}(sh .guides/bg.sh javac code/2/Goodbye.java java -cp code/2/ Goodbye )
    
          position: 351
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/1/Goodbye.java"
            panel: 0
            action: open
          - path: "code/2/Goodbye.java"
            panel: 1
            action: open
  - name: Escape sequences
    type: section
    transformations:
        - add:  |
             See the example java code in the left panel. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Hello3.java java -cp code/ Hello3 )
     
          position: 395
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Hello3.java"
          panel: 0
          action: open
  - name: What is computer science?
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Debugging programs
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Vocabulary
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 68
        position: 655
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 1.1
    type: section
    chapter: Computer programming
    section: Exercises
  - name: Exercise 1.2
    type: section
    chapter: Computer programming
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_1_2.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 1.3
    type: section
    chapter: Computer programming
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_1_2.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
# Chapter 2
  - name: Variables and operators
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Declaring variables
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Assigning variables
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Memory diagrams
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Printing variables
    type: section
    transformations:
        - add:  |
             See the example java code in the left panel. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Printing.java java -cp code/ Printing )
     
          position: 211
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Printing.java"
          panel: 0
          action: open
  - name: Arithmetic operators
    type: section
    transformations:
        - add:  |
             See the example java code in the left panel. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Arithmetic.java java -cp code/ Arithmetic )
     
          position: 278
        - add:  |

             {Run!}(sh .guides/bg.sh javac code/Arithmetic.java java -cp code/ Arithmetic 2 )
     
          position: 308
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Arithmetic.java"
          panel: 0
          action: open
  - name: Floating-point numbers
    type: section
    transformations:
        - add:  |
             See the example java code in the left panel. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Floating.java java -cp code/ Floating )
     
          position: 364
        - add:  |

             {Run!}(sh .guides/bg.sh javac code/Floating.java java -cp code/ Floating 2 )
     
          position: 397
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Floating.java"
          panel: 0
          action: open
  - name: Rounding errors
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Operators for strings
    type: section
    transformations:
        - add:  |
             See the example java code in the left panel. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/StringOps.java java -cp code/ StringOps )
     
          position: 505
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/StringOps.java"
          panel: 0
          action: open
  - name: Compiler error messages
    type: section
    transformations:
        - add:  |
             Follow along using the example java code in the left panel. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/1/Hello.java java -cp code/1/ Hello )
     
          position: 575
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/1/Hello.java"
          panel: 0
          action: open
  - name: Other types of errors
    type: section
    transformations:
        - remove: 1
          position: 653
        - add:  |
             For example, see a version of the hello world program with a logic error in the left panel. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/2/Hello.java java -cp code/2/ Hello )
     
          position: 654
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/2/Hello.java"
          panel: 0
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 80
        position: 770
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 2.1
    type: section
    chapter: Variables and operators
    section: Exercises
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Exercise 2.2
    type: section
    chapter: Variables and operators
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_2_2.java"
          panel: 0
          action: open
  - name: Exercise 2.3
    type: section
    chapter: Variables and operators
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_2_3.java"
          panel: 0
          action: open
#Chapter 3
  - name: Input and output
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: The System class
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: The Scanner class
    type: section
    transformations:
        - add:  |
            [Highlight in Code](open_file code/Echo.java panel=0 ref="import" count=1)
  
          position: 87
        - add:  |
            [Highlight in Code](open_file code/Echo.java panel=0 ref="Scanner in" count=1)
  
          position: 104
        - remove: 1
          position: 106
        - add:  |
             
             See the example java code in the top-left panel. This example reads two lines and repeats them back to the user. To compile and run the code, press the "Run!"
             {Run! | terminal}(javac code/Echo.java && java -cp code/ Echo)
     
          position: 108
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/Echo.java"
            panel: 0
            action: open
          - path: "#terminal: "
            panel: 1
            action: open
  - name: Language elements
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Literals and constants
    type: section
    transformations:
        - add:  |
             Follow along in the top-left panel. To compile and run the code, press the "Run!"
             {Run! | terminal}(javac code/Literals.java && java -cp code/ Literals)
     
          position: 196
        - add:  |
             [Highlight in Code](open_file code/Literals.java panel=0 ref="int inch" count=3)
  
          position: 204
        - add:  |
             [Highlight in Code](open_file code/Literals.java panel=0 ref="How many inches?" count=2)
  
          position: 216
        - add:  |
             [Highlight in Code](open_file code/Literals.java panel=0 ref="inch * 2.54" count=3)
             
             {Run! | terminal}(javac code/Literals.java && java -cp code/ Literals )
     
          position: 225
        - add:  |
             
             {Run! | terminal}(javac code/Literals.java && java -cp code/ Literals )
     
          position: 262
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/Literals.java"
            panel: 0
            action: open
          - path: "#terminal: "
            panel: 1
            action: open
  - name: Formatting output
    type: section
    transformations:
        - add:  |
             
             Try it out in the top-right panel. To compile and run the code, press the "Run!"
             {Run! | terminal}(javac code/Formatting.java && java -cp code/ Formatting)
     
          position: 276
        - add:  |
             
             {Run! | terminal}(javac code/Formatting.java && java -cp code/ Formatting )
     
          position: 314
    configuration:
      layout: 3-cell-left
      files:
          - path: "#tabs"
            action: close
          - path: "code/Formatting.java"
            panel: 1
            action: open
          - path: "#terminal: "
            panel: 2
            action: open
  - name: Type cast operators
    type: section
    transformations:
        - add:  |
             
             Try it out in the left panel. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Casting.java java -cp code/ Casting )
     
          position: 411
        - add:  |
             
             {Run!}(sh .guides/bg.sh javac code/Casting.java java -cp code/ Casting 3 )
     
          position: 446
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/Casting.java"
            panel: 0
            action: open
  - name: Remainder operator
    type: section
    transformations:
        - add:  |
             
             Try it out in the left panel.
             {Run!}(sh .guides/bg.sh javac code/Remainder.java java -cp code/ Remainder )
     
          position: 471
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/Remainder.java"
            panel: 0
            action: open
  - name: Putting it all together
    type: section
    transformations:
        - remove: 1
          position: 501
        - add:  |
             Take a look at the code in the left panel which puts everything together in a complete program.
             {Run! | terminal}(javac code/Convert.java && java -cp code/ Convert )
     
          position: 502
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/Convert.java"
            panel: 0
            action: open
          - path: "#terminal: "
            panel: 1
            action: open
  - name: The Scanner bug
    type: section
    transformations:
        - add:  |
            [Highlight in Code](open_file code/ScannerBug.java panel=0 ref="What is your name?" count=5)
            
            {Run! | terminal}(javac code/ScannerBug.java && java -cp code/ ScannerBug)
  
          position: 564
        - add:  |
             
             {Run! | terminal}(javac code/ScannerBug.java && java -cp code/ ScannerBug)
     
          position: 583
        - add:  |
             
             Fix the code on the left and try running it again.
             {Run! | terminal}(javac code/ScannerBug.java && java -cp code/ ScannerBug)
     
          position: 628
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/ScannerBug.java"
            panel: 0
            action: open
          - path: "#terminal: "
            panel: 1
            action: open
  - name: Vocabulary
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 3
        position: 717
      - remove: 100
        position: 724
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 3.1
    type: section
    chapter: Input and output
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_3_1.java"
          panel: 0
          action: open
  - name: Exercise 3.2
    type: section
    chapter: Input and output
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/CtoF.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 3.3
    type: section
    chapter: Input and output
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/TimeConv.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 3.4
    type: section
    chapter: Input and output
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/ch03/GuessStarter.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
#Chapter 4
  - name: Methods and testing
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Math methods
    type: section
    transformations:
        - add:  |
             Try out some of these Math functions in the panel to the left.
             {Run!}(sh .guides/bg.sh javac code/MathFun.java java -cp code/ MathFun )
 
          position: 48
        - add:  |

            {Run!}(sh .guides/bg.sh javac code/MathFun.java java -cp code/ MathFun 2 )
 
          position: 65
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/MathFun.java"
          panel: 0
          action: open
  - name: Composition
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Defining new methods
    type: section
    transformations:
        - add:  |
             See the example java code in the top-left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/NewLine.java java -cp code/ NewLine )
  
          position: 162
        - add:  |
             See the example java code in the bottom-left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/1/NewLine.java java -cp code/1/ NewLine 2 )
   
          position: 200
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/NewLine.java"
          panel: 0
          action: open
        - path: "code/1/NewLine.java"
          panel: 1
          action: open
  - name: Flow of execution
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Parameters and arguments
    type: section
    transformations:
        - remove: 1
          position: 284
        - add: |
             The class in the top-left pane shows an example.
             {Run!}(sh .guides/bg.sh javac code/PrintTwice.java java -cp code/ PrintTwice )
  
          position: 285
        - remove: 1
          position: 402
        - add: | 
             
             You can see the pulled together code fragments in the bottom-left pane.
             {Run!}(sh .guides/bg.sh javac code/PrintTime.java java -cp code/ PrintTime )
   
          position: 403
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/PrintTwice.java"
          panel: 0
          action: open
        - path: "code/PrintTime.java"
          panel: 1
          action: open
  - name: Stack diagrams
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Return values
    type: section
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Return.java"
          panel: 0
          action: open
        - path: "#tutor: code/Return.java"
          panel: 1
          action: open
  - name: Incremental development
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 216
        position: 763
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 4.1
    type: section
    chapter: Methods and testing
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_2_2.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 4.2
    type: section
    chapter: Methods and testing
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_4_2.java"
          panel: 0
          action: open
  - name: Exercise 4.3
    type: section
    chapter: Methods and testing
    section: Exercises
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 4.4
    type: section
    chapter: Methods and testing
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_4_4.java"
          panel: 0
          action: open
  - name: Exercise 4.5
    type: section
    chapter: Methods and testing
    section: Exercises
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 4.6
    type: section
    chapter: Methods and testing
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_4_6.java"
          panel: 0
          action: open
#Chapter 5
  - name: Conditionals and logic
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Relational operators
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: The if-else statement
    type: section
    transformations:
        - add:  |
             Try it out in the panel to the left. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/IfElse.java java -cp code/ IfElse )
  
          position: 82
        - add:  |

             {Run!}(sh .guides/bg.sh javac code/IfElse.java java -cp code/ IfElse 2 )
  
          position: 124
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/IfElse.java"
          panel: 0
          action: open
  - name: Chaining and nesting
    type: section
    transformations:
        - add:  |
             Try it out in the pane to the left. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Chaining.java java -cp code/ Chaining )
  
          position: 187
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/Chaining.java java -cp code/ Chaining 2 )
  
          position: 212
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Chaining.java"
          panel: 0
          action: open
  - name: Logical operators
    type: section
    transformations:
        - add:  |
             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/LogicalOps.java java -cp code/ LogicalOps )
  
          position: 259
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/LogicalOps.java java -cp code/ LogicalOps 2 )
  
          position: 277
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/LogicalOps.java"
          panel: 0
          action: open
  - name: De Morgan's laws
    type: section
    configuration:
            layout: 1-panel
            files:
                - path: "#tabs"
                  action: close
  - name: Boolean variables
    type: section
    transformations:
        - add:  |
             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/BooleanVars.java java -cp code/ BooleanVars )
  
          position: 364
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/BooleanVars.java"
          panel: 0
          action: open
  - name: Boolean methods
    type: section
    transformations:
        - add:  |
             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/BooleanMethods.java java -cp code/ BooleanMethods )
  
          position: 421
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/BooleanMethods.java"
          panel: 0
          action: open
  - name: Validating input
    type: section
    transformations:
        - add: |
          
             Try it out by clicking the button below:
             {Run! | terminal}(javac code/ValidInput.java && java -cp code/ ValidInput)
  
          position: 470
        - add: |
          
             {Run! | terminal}(javac code/ValidInput.java && java -cp code/ ValidInput)
  
          position: 515
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/ValidInput.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Example program
    type: section
    transformations:
        - remove: 1
          position: 539
        - add: | 

              The program on the left shows how the individual code examples in the last section fit together.
              {Run! | terminal}(javac code/Logarithm.java && java -cp code/ Logarithm)
  
          position: 540
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Logarithm.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 177
        position: 646
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 5.1
    type: section
    chapter: Conditionals and logic
    section: Exercises
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 5.2
    type: section
    chapter: Conditionals and logic
    section: Exercises
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 5.3
    type: section
    chapter: Conditionals and logic
    section: Exercises
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 5.4
    type: section
    chapter: Conditionals and logic
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Fermat.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 5.5
    type: section
    chapter: Conditionals and logic
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/ch03/GuessStarter.java"
          panel: 0
          action: open
  - name: Exercise 5.6
    type: section
    chapter: Conditionals and logic
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Quadratic.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 5.7
    type: section
    chapter: Conditionals and logic
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Triangle.java"
          panel: 0
          action: open
        - path: "code/Quadratic.java"
          panel: 1
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
#Chapter 6
  - name: Loops and strings
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: The while statement
    type: section
    transformations:
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/BlastOff.java java -cp code/ BlastOff )
  
          position: 30
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/BlastOff.java java -cp code/ BlastOff 2)
  
          position: 100
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/BlastOff.java"
          panel: 0
          action: open
        - path: "#tutor: code/BlastOff.java"
          panel: 1
          action: open
  - name: Increment and decrement
    type: section
    transformations:
        - add:  |
             Try it out using the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Increment.java java -cp code/ Increment )
  
          position: 130
        - add:  |
            {Run!}(sh .guides/bg.sh javac code/Increment.java java -cp code/ Increment 2 )
  
          position: 148
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Increment.java"
          panel: 0
          action: open
  - name: The for statement
    type: section
    transformations:
        - add: |
          
              {Run!}(sh .guides/bg.sh javac code/For.java java -cp code/ For )
  
          position: 178
        - add: |
          
              {Run!}(sh .guides/bg.sh javac code/For.java java -cp code/ For 2)
  
          position: 215
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/For.java"
          panel: 0
          action: open
        - path: "#tutor: code/For.java"
          panel: 1
          action: open
  - name: Nested loops
    type: section
    transformations:
        - add:  |
             See the example java code in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/MultiplicationTable.java java -cp code/ MultiplicationTable )
  
          position: 253
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/MultiplicationTable.java"
          panel: 0
          action: open
  - name: Characters
    type: section
    transformations:
        - remove: 1
          position: 87
        - add:  |

             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Characters.java java -cp code/ Characters )
  
          position: 303
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/Characters.java java -cp code/ Characters 2 )
  
          position: 327
        - add:  |

             {Run!}(sh .guides/bg.sh javac code/Characters.java java -cp code/ Characters 3 )
  
          position: 360
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Characters.java"
          panel: 0
          action: open
  - name: String iteration
    type: section
    transformations:
        - remove: 1
          position: 87
        - add:  |
             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/StringIteration.java java -cp code/ StringIteration )
  
          position: 404
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/StringIteration.java"
          panel: 0
          action: open
  - name: The indexOf method
    type: section
    transformations:
        - add:  |
             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/IndexOf.java java -cp code/ IndexOf )
  
          position: 438
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/IndexOf.java"
          panel: 0
          action: open
  - name: String comparison
    type: section
    transformations:
        - add:  |

             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/StringComp.java java -cp code/ StringComp )
  
          position: 497
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/StringComp.java java -cp code/ StringComp 2 )
  
          position: 529
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/StringComp.java"
          panel: 0
          action: open
  - name: Substrings
    type: section
    transformations:
        - add:  |

             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Substring.java java -cp code/ Substring )
  
          position: 559
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Substring.java"
          panel: 0
          action: open
  - name: String formatting
    type: section
    transformations:
        - add:  |

             Try it out in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/StringFormat.java java -cp code/ StringFormat )
  
          position: 601
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/StringFormat.java"
          panel: 0
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 137
        position: 660
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 6.1
    type: section
    chapter: Loops and strings
    section: Exercises
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 6.2
    type: section
    chapter: Loops and strings
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_6_2.java"
          panel: 0
          action: open
  - name: Exercise 6.3
    type: section
    chapter: Loops and strings
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_6_3.java"
          panel: 0
          action: open
  - name: Exercise 6.4
    type: section
    chapter: Loops and strings
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_6_4.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 6.5
    type: section
    chapter: Loops and strings
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_6_5.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 6.6
    type: section
    chapter: Loops and strings
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_6_6.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
# Chapter 7
  - name: Arrays and references
    type: chapter
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Creating arrays
    type: section
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/CreatingArrays.java"
            panel: 0
            action: open
          - path: "#tutor: code/CreatingArrays.java"
            panel: 1
            action: open
  - name: Accessing elements
    type: section
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/AccessingElements.java"
            panel: 0
            action: open
          - path: "#tutor: code/AccessingElements.java"
            panel: 1
            action: open
  - name: Displaying arrays
    type: section
    transformations:
        - add:  |
             See the example java code in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/DisplayingArrays.java java -cp code/ DisplayingArrays )
  
          position: 181
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/DisplayingArrays.java java -cp code/ DisplayingArrays )
  
          position: 217
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/DisplayingArrays.java"
            panel: 0
            action: open
  - name: Copying arrays
    type: section
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/CopyingArrays.java"
            panel: 0
            action: open
          - path: "#tutor: code/CopyingArrays.java"
            panel: 1
            action: open
  - name: Array traversal
    type: section
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/TraversingArrays.java"
            panel: 0
            action: open
          - path: "#tutor: code/TraversingArrays.java"
            panel: 1
            action: open
  - name: Random numbers
    type: section
    transformations:
        - add:  |
             See the example java code in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/RandomNums.java java -cp code/ RandomNums )
  
          position: 439
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/RandomNums.java"
            panel: 0
            action: open
  - name: Building a histogram
    type: section
    transformations:
        - add:  |
             See the example java code in the right pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Remainder.java java -cp code/ Remainder )
  
          position: 502
    configuration:
      layout: 2-panels-guides-left
      files:
          - path: "#tabs"
            action: close
          - path: "code/Histogram.java"
            panel: 1
            action: open
  - name: The enhanced for loop
    type: section
    configuration:
      layout: 3-cell
      files:
          - path: "#tabs"
            action: close
          - path: "code/Enhanced.java"
            panel: 0
            action: open
          - path: "#tutor: Enhanced.java"
            panel: 1
            action: open
  - name: Counting characters
    type: section
    transformations:
        - add:  |
             See the example java code in the left pane. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/Doubloon.java java -cp code/ Doubloon )
  
          position: 658
    configuration:
      layout: 2-panels
      files:
          - path: "#tabs"
            action: close
          - path: "code/Doubloon.java"
            panel: 0
            action: open
  - name: Vocabulary
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
       - remove: 142
         position: 760
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 7.1
    type: section
    chapter: Arrays and references
    section: Exercises
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 7.2
    type: section
    chapter: Arrays and references
    section: Exercises
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 7.3
    type: section
    chapter: Arrays and references
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/IndexOfMax.java"
          panel: 0
          action: open
  - name: Exercise 7.4
    type: section
    chapter: Arrays and references
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Sieve.java"
          panel: 0
          action: open
  - name: Exercise 7.5
    type: section
    chapter: Arrays and references
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_7_5.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 7.6
    type: section
    chapter: Arrays and references
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_7_6.java"
          panel: 0
          action: open
        - path: "code/Exercise_7_5.java"
          panel: 1
          action: open
  - name: Exercise 7.7
    type: section
    chapter: Arrays and references
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_7_7.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 7.8
    type: section
    chapter: Arrays and references
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Anagrams.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
# Chapter 8
  - name: Recursive methods
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Recursive void methods
    type: section
    transformations:
        - add: |

             {Run!}(sh .guides/bg.sh javac code/Countdown.java java -cp code/ Countdown )
  
          position: 31
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Countdown.java"
          panel: 0
          action: open
        - path: "#tutor: code/Countdown.java"
          panel: 1
          action: open
  - name: Recursive stack diagrams
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Value returning methods
    type: section
    transformations:
        - add: |

              Follow along in the top-left pane.
              {Run!}(sh .guides/bg.sh javac code/ValueReturning.java java -cp code/ ValueReturning )
 
          position: 203
        - add: |

              {Run!}(sh .guides/bg.sh javac code/ValueReturning.java java -cp code/ ValueReturning 2 )
 
          position: 234
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/ValueReturning.java"
          panel: 0
          action: open
        - path: "#tutor: code/ValueReturning.java"
          panel: 1
          action: open
  - name: The leap of faith
    type: section
    transformations:
        - add: |

              {Run!}(sh .guides/bg.sh javac code/Fibonacci.java java -cp code/ Fibonacci )
        
          position: 351
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Fibonacci.java"
          panel: 0
          action: open
        - path: "#tutor: code/Fibonacci.java"
          panel: 1
          action: open
  - name: Binary number system
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Recursive binary method
    type: section
    transformations:
        - add: |

              {Run!}(sh .guides/bg.sh javac code/DisplayBinary.java java -cp code/ DisplayBinary )
        
          position: 492
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/DisplayBinary.java"
          panel: 0
          action: open
        - path: "#tutor: code/DisplayBinary.java"
          panel: 1
          action: open
  - name: CodingBat problems
    type: section
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "#preview: https://codingbat.com/prob/p118230"
          panel: 0
          action: open
        - path: "#preview: https://codingbat.com/prob/p135988"
          panel: 1
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 221
        position: 670
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 8.1
    type: section
    chapter: Recursive methods
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_8_1.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 8.2
    type: section
    chapter: Recursive methods
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_8_2.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 8.3
    type: section
    chapter: Recursive methods
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_8_3.java"
          panel: 0
          action: open
  - name: Exercise 8.4
    type: section
    chapter: Recursive methods
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_8_4.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 8.5
    type: section
    chapter: Recursive methods
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_8_5.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: Exercise 8.6
    type: section
    chapter: Recursive methods
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_8_6.java"
          panel: 0
          action: open
  - name: Exercise 8.7
    type: section
    chapter: Recursive methods
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Recurse.java"
          panel: 0
          action: open
# Chapter 9
  - name: Immutable objects
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Primitives vs objects
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Strings are immutable
    type: section
    transformations:
        - add:  |
             Try it out in the panel to the left. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/ImmutableStrings.java java -cp code/ ImmutableStrings )
  
          position: 152
        - add:  |
              {Run!}(sh .guides/bg.sh javac code/ImmutableStrings.java java -cp code/ ImmutableStrings 2 )
 
          position: 173
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/ImmutableStrings.java"
          panel: 0
          action: open
  - name: Wrapper classes
    type: section
    transformations:
        - add:  |
              Try it out in the panel to the left. To compile and run the code, press the "Run!"
              {Run!}(sh .guides/bg.sh javac code/Wrapper.java java -cp code/ Wrapper )
  
          position: 236
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Wrapper.java java -cp code/ Wrapper 2 )
 
          position: 261
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Wrapper.java"
          panel: 0
          action: open
  - name: Command-line arguments
    type: section
    transformations:
        - remove: 5
          position: 296
        - add:  |

              You can compile the example code by either typing `javac code/Max.java` into the command line in the bottom-left pane or clicking the button below.
              {Compile | terminal}(javac code/Max.java)
              
              You can run this program from the command line in the bottom-left pane by typing `java -cp code/ Max`
  
          position: 295
        - remove: 3
          position: 313
        - add:  |
              `java -cp code/ Max 10 -3 55 0 14`
 
          position: 316
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Max.java"
          panel: 0
          action: open
        - path: "#terminal: "
          panel: 1
          action: open
  - name: BigInteger arithmetic
    type: section
    transformations:
        - add:  |

             Try it out yourself in the pane to the left. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/BigInt.java java -cp code/ BigInt )
  
          position: 391
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/BigInt.java"
          panel: 0
          action: open
  - name: Program development
    type: section
    transformations:
        - add:  |
             Try it out yourself in the pane to the left. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/ProgramDev.java java -cp code/ ProgramDev )
  
          position: 455
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/ProgramDev.java java -cp code/ ProgramDev 2 )
 
          position: 488
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/ProgramDev.java java -cp code/ ProgramDev 3 )
 
          position: 502
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/ProgramDev.java java -cp code/ ProgramDev 4 )
 
          position: 526
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/ProgramDev.java"
          panel: 0
          action: open
  - name: More generalization
    type: section
    transformations:
        - add:  |
             Try it out yourself in the pane to the left. To compile and run the code, press the "Run!"
             {Run!}(sh .guides/bg.sh javac code/ProgramDev.java java -cp code/ ProgramDev 5 )
  
          position: 569
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/ProgramDev.java java -cp code/ ProgramDev 6 )
 
          position: 595
        - add:  |
             {Run!}(sh .guides/bg.sh javac code/ProgramDev.java java -cp code/ ProgramDev 7 )
 
          position: 631
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/ProgramDev.java"
          panel: 0
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 203
        position: 696
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 9.1
    type: section
    chapter: Immutable objects
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Test.java"
          panel: 0
          action: open
  - name: Exercise 9.2
    type: section
    chapter: Immutable objects
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/CopyingArrays.java"
          panel: 0
          action: open
        - path: "code/Histogram.java"
          panel: 1
          action: open
  - name: Exercise 9.3
    type: section
    chapter: Immutable objects
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Big.java"
          panel: 0
          action: open
  - name: Exercise 9.4
    type: section
    chapter: Immutable objects
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/BigInteger2.java"
          panel: 0
          action: open
  - name: Exercise 9.5
    type: section
    chapter: Immutable objects
    section: Exercises
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_9_5.java"
          panel: 0
          action: open
        - path: "code/ValueReturning.java"
          panel: 1
          action: open
  - name: Exercise 9.6
    type: section
    chapter: Immutable objects
    section: Exercises
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Exercise_9_6.java"
          panel: 0
          action: open
#Chapter 10
  - name: Mutable objects
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Point objects
    type: section
    transformations:
        - add:  |
              Try it out in the pane to the left. To compile and run the code, press the "Run!"
              {Run!}(sh .guides/bg.sh javac code/PointObjs.java java -cp code/ PointObjs )
  
          position: 47
        - add:  |
              {Run!}(sh .guides/bg.sh javac code/PointObjs.java java -cp code/ PointObjs 2 )
 
          position: 82
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/PointObjs.java"
          panel: 0
          action: open
  - name: Objects as parameters
    type: section
    transformations:
        - add:  |
              Try it out in the pane to the left. To compile and run the code, press the "Run!"
              {Run!}(sh .guides/bg.sh javac code/PointObjs.java java -cp code/ PointObjs )
  
          position: 114
        - add:  |
              {Run!}(sh .guides/bg.sh javac code/PointObjs.java java -cp code/ PointObjs 2 )
 
          position: 138
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/PointObjs.java"
          panel: 0
          action: open
  - name: Objects as return types
    type: section
    transformations:
        - add:  |
              Try it out in the pane to the left. To compile and run the code, press the "Run!"
              {Run!}(sh .guides/bg.sh javac code/ReturnObjs.java java -cp code/ ReturnObjs )
  
          position: 171
        - add:  |
              {Run!}(sh .guides/bg.sh javac code/ReturnObjs.java java -cp code/ ReturnObjs 2 )
 
          position: 203
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/ReturnObjs.java"
          panel: 0
          action: open
  - name: Rectangles are mutable
    type: section
    transformations:
        - add:  |
              Try it out in the pane to the left. To compile and run the code, press the "Run!"
              {Run!}(sh .guides/bg.sh javac code/ReturnObjs.java java -cp code/ ReturnObjs )
  
          position: 244
        - add:  |
              {Run!}(sh .guides/bg.sh javac code/ReturnObjs.java java -cp code/ ReturnObjs 2 )
 
          position: 274
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/ReturnObjs.java"
          panel: 0
          action: open
  - name: Aliasing revisited
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Java library source
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Class diagrams
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Garbage collection
    type: section
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Mutable vs immutable
    type: section
    transformations:
        - remove: 1
          position: 491
        - add:  |

              The Java compiler automatically detecets this situation. See the example in the top-left panel. To run the example, click the "Run!" button below.
              {Run!}(sh .guides/bg.sh javac code/Surprise.java java -cp code/ Surprise )
  
          position: 492
        - remove: 1
          position: 521
        - add:  |

              Consider the program in the bottom-left panel that inputs ten lines from `System.in` and concatenates them into a single `String`. To run the example, click the "Run!" button below.
              {Run! | terminal}(javac code/Append.java && java -cp code/ Append)
  
          position: 522
        - add:  |

              {Run! | terminal}(javac code/Append.java && java -cp code/ Append)
  
          position: 562
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Surprise.java"
          panel: 0
          action: open
        - path: "code/Append.java"
          panel: 1
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 102
        position: 613
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 10.1
    type: section
    chapter: Mutable objects
    section: Exercises
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercise 10.2
    type: section
    chapter: Mutable objects
    section: Exercises
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercise 10.3
    type: section
    chapter: Mutable objects
    section: Exercises
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
#Chapter 11
  - name: Designing classes
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: The Time class
    type: section
    transformations:
        - add:  |
             [Highlight in Code](open_file code/Time.java panel=0 ref="public class Time" count=5)
  
          position: 78
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
  - name: Constructors
    type: section
    transformations:
        - add:  |
             [Highlight in Code](open_file code/Time.java panel=0 ref="public Time()" count=5)
  
          position: 118
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time )
 
          position: 143
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
  - name: More constructors
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time )
 
          position: 213
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
  - name: Getters and setters
    type: section
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
        - path: "code/TimeClient.java"
          panel: 1
          action: open
  - name: Displaying objects
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time )
 
          position: 351
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time 2 )
 
          position: 394
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
  - name: The toString method
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time )
 
          position: 451
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
  - name: The equals method
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time )
 
          position: 521
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time 2 )
 
          position: 543
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
  - name: Adding times
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time )
 
          position: 591
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time 2 )
 
          position: 623
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time 3 )
 
          position: 649
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
  - name: Pure methods
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Time.java java -cp code/ Time )
 
          position: 679
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Time.java"
          panel: 0
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 117
        position: 771
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 11.1
    type: section
    chapter: Designing classes
    section: Exercises
  - name: Exercise 11.2
    type: section
    chapter: Designing classes
    section: Exercises
  - name: Exercise 11.3
    type: section
    chapter: Designing classes
    section: Exercises
  - name: Exercise 11.4
    type: section
    chapter: Designing classes
    section: Exercises
  - name: Exercise 11.5
    type: section
    chapter: Designing classes
    section: Exercises
#Chapter 12
  - name: Arrays of objects
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Card objects
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 103
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
  - name: Card toString
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 190
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
  - name: Class variables
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 233
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
  - name: The compareTo method
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 267
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card 2 )
 
          position: 317
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
  - name: Cards are immutable
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 338
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card 2 )
 
          position: 360
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
  - name: Arrays of cards
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 387
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card 2 )
 
          position: 434
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card 3 )
 
          position: 464
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
  - name: Sequential search
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 499
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
  - name: Binary search
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 562
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
  - name: Tracing the code
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 601
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
        - path: "#tutor: code/Card.java"
          panel: 1
          action: open
  - name: Recursive version
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Card.java java -cp code/ Card )
 
          position: 670
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Card.java"
          panel: 0
          action: open
        - path: "#tutor: code/Card.java"
          panel: 1
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 98
        position: 713
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 12.1
    type: section
    chapter: Arrays of objects
    section: Exercises
  - name: Exercise 12.2
    type: section
    chapter: Arrays of objects
    section: Exercises
  - name: Exercise 12.3
    type: section
    chapter: Arrays of objects
    section: Exercises
  - name: Exercise 12.4
    type: section
    chapter: Arrays of objects
    section: Exercises
#Chapter 13
  - name: Objects of arrays
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Decks of cards
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Deck.java java -cp code/ Deck )
 
          position: 72
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Deck.java"
          panel: 0
          action: open
  - name: Shuffling decks
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Deck.java java -cp code/ Deck )
 
          position: 153
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Deck.java"
          panel: 0
          action: open
  - name: Selection sort
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Deck.java java -cp code/ Deck )
 
          position: 201
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Deck.java"
          panel: 0
          action: open
  - name: Merge sort
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Subdecks
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Deck.java java -cp code/ Deck )
 
          position: 263
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Deck.java"
          panel: 0
          action: open
  - name: Merging decks
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Deck.java java -cp code/ Deck )
 
          position: 335
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Deck.java"
          panel: 0
          action: open
  - name: Adding recursion
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Deck.java java -cp code/ Deck )
 
          position: 374
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Deck.java"
          panel: 0
          action: open
  - name: Static context
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Deck.java java -cp code/ Deck )
 
          position: 430
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Deck.java"
          panel: 0
          action: open
  - name: Piles of cards
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Pile.java java -cp code/ Pile )
 
          position: 501
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Pile.java java -cp code/ Pile 2 )
 
          position: 542
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Pile.java java -cp code/ Pile 3 )
 
          position: 568
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Pile.java java -cp code/ Pile 4 )
 
          position: 588
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Pile.java"
          panel: 0
          action: open
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 124
        position: 647
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 13.1
    type: section
    chapter: Objects of arrays
    section: Exercises
  - name: Exercise 13.2
    type: section
    chapter: Objects of arrays
    section: Exercises
  - name: Exercise 13.3
    type: section
    chapter: Objects of arrays
    section: Exercises
  - name: Exercise 13.4
    type: section
    chapter: Objects of arrays
    section: Exercises
  - name: Exercise 13.5
    type: section
    chapter: Objects of arrays
    section: Exercises
  - name: Exercise 13.6
    type: section
    chapter: Objects of arrays
    section: Exercises
#Chapter 14
  - name: Extending classes
    type: chapter
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: CardCollection
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/CardCollection.java java -cp code/ CardCollection )
 
          position: 99
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/CardCollection.java java -cp code/ CardCollection 2 )
 
          position: 138
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/CardCollection.java java -cp code/ CardCollection 3)
 
          position: 173
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/CardCollection.java"
          panel: 0
          action: open
  - name: Inheritance
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Deck.java java -cp code/ Deck )
 
          position: 206
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Hand.java java -cp code/ Hand )
 
          position: 263
    configuration:
      layout: 3-cell
      files:
        - path: "#tabs"
          action: close
        - path: "code/Deck.java"
          panel: 0
          action: open
        - path: "code/Hand.java"
  - name: Dealing cards
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/CardCollection.java java -cp code/ CardCollection )
 
          position: 316
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/CardCollection.java"
          panel: 0
          action: open
  - name: The Player class
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Player.java java -cp code/ Player )
 
          position: 394
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Player.java java -cp code/ Player 2 )
 
          position: 432
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Player.java java -cp code/ Player )
 
          position: 455
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Player.java"
          panel: 0
          action: open
  - name: The Eights class
    type: section
    transformations:
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Eights.java java -cp code/ Eights )
 
          position: 570
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Eights.java java -cp code/ Eights 2 )
 
          position: 597
        - add:  |

              {Run!}(sh .guides/bg.sh javac code/Eights.java java -cp code/ Eights 3)
 
          position: 646
    configuration:
      layout: 2-panels
      files:
        - path: "#tabs"
          action: close
        - path: "code/Eights.java"
          panel: 0
          action: open
  - name: Class relationships
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Vocabulary
    type: section
    configuration:
        layout: 1-panel
        files:
            - path: "#tabs"
              action: close
  - name: Exercises
    type: section
    codio_section: start
    transformations:
      - remove: 47
        position: 748
    configuration:
      layout: 1-panel
      files:
          - path: "#tabs"
            action: close
  - name: Exercise 14.1
    type: section
    chapter: Extending classes
    section: Exercises
  - name: Exercise 14.2
    type: section
    chapter: Extending classes
    section: Exercises
  - name: Exercise 14.3
    type: section
    chapter: Extending classes
    section: Exercises
  - name: Exercise 14.4
    type: section
    chapter: Extending classes
    section: Exercises
#Appendix A
  - name: Tools
    type: chapter
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Installing DrJava
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: DrJava interactions
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Command-line interface
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Command-line testing
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Running Checkstyle
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Tracing with a debugger
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Testing with JUnit
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Vocabulary
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
#Appendix B
  - name: Javadoc
    type: chapter
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Reading documentation
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Writing documentation
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Javadoc tags
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Example source file
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Vocabulary
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
#Appendix C
  - name: Graphics
    type: chapter
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Creating graphics
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Graphics methods
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Example drawing
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Vocabulary
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Exercises
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
#Appendix D
  - name: Debugging
    type: chapter
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Compile-time errors
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Run-time errors
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Logic errors
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
#Appendix E
  - name: Extras
    type: chapter
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Unreachable code
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Method composition
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Overloading methods
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Generating tables
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: The do-while loop
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
  - name: Break and continue
    type: section
    configuration:
    layout: 1-panel
    files:
        - path: "#tabs"
          action: close
#inserting exercises on seperate pages so that they are cherry-pick-able
insert_sections:
#Chapter 1
  - name: Exercise 1.1
    type: section
    chapter: Computer programming
    section: Exercises
    before: false
    markdown: |
      Computer scientists have the annoying habit of using common English words to mean something other than their common English meaning. For example, in English, statements and comments are the same thing, but in programs they are different.


      1.  {Submit Answer!|assessment}(free-text-2791946401)

      1.  {Submit Answer!|assessment}(free-text-3354245947)

      1.  {Submit Answer!|assessment}(free-text-824459802)

      1.  {Submit Answer!|assessment}(free-text-3752516518)


      The glossary at the end of each chapter is intended to highlight words and phrases that have special meanings in computer science. When you see familiar words, don't assume that you know what they mean!
  - name: Exercise 1.2
    type: section
    chapter: Computer programming
    section: Exercises
    before: false
    markdown: |
      Before you do anything else, find out how to compile and run a Java program. Some environments provide sample programs similar to the example in Section 1.3.

      1.  Type in the hello world program, then compile and run it. You can do this by entering `javac code/Exercise_1_2.java` followed by `java -cp code/ Exercise_1_2` or by pressing the button below:
          {Run! | terminal}(javac code/Exercise_1_2.java && java -cp code/ Exercise_1_2)
      1.  Add a print statement that displays a second message after the “Hello, World!”.
          Say something witty like, “How are you?”
          Compile and run the program again.
      1.  Add a comment to the program (anywhere), recompile, and run it again.
          The new comment should not affect the result.

      {Check It!|assessment}(code-output-compare-1005800380)


      This exercise may seem trivial, but it is the starting place for many of the programs we will work with. To debug with confidence, you will need to have confidence in your programming environment. In some environments, it is easy to lose track of which program is executing. You might find yourself trying to debug one program while you are accidentally running another. Adding (and changing) print statements is a simple way to be sure that the program you are looking at is the program you are running.
  - name: Exercise 1.3
    type: section
    chapter: Computer programming
    section: Exercises
    before: false
    markdown: |
      It is a good idea to commit as many errors as you can think of, so that you see what error messages the compiler produces. Sometimes the compiler tells you exactly what is wrong, and all you have to do is fix it. But sometimes the error messages are misleading. Over time you will develop a sense for when you can trust the compiler and when you have to figure things out yourself. 

      Starting with the hello world program, try out each of the following errors. After you make each change, compile the program, read the error message (if there is one), and then fix the error.

      1.  Remove one of the open curly braces.
      1.  Remove one of the close curly braces.
      1.  Instead of `main`, write `mian`.
      1.  Remove the word `static`.
      1.  Remove the word `public`.
      1.  Remove the word `System`.
      1.  Replace `println` with `Println`.
      1.  Replace `println` with `print`.
      1.  Delete one of the parentheses.
      1.  Add an extra parenthesis.

      {Run! | terminal}(javac code/Exercise_1_2.java && java -cp code/ Exercise_1_2)

      {Check It!|assessment}(fill-in-the-blanks-1099192244)
#Chapter 2
  - name: Exercise 2.1
    type: section
    chapter: Variables and operators
    section: Exercises
    before: false
    markdown: |
      If you are using this book in a class, you might enjoy this exercise. Find a partner and play “Stump the Chump”:

      1. Start with a program that compiles and runs correctly.
      1. One player looks away while the other player adds an error to the program.
      1. Then the first player tries to find and fix the error.
      1. You get two points if you find the error without compiling the program, one point if you find it using the compiler, and your opponent gets a point if you don't find it.
  - name: Exercise 2.2
    type: section
    chapter: Variables and operators
    section: Exercises
    before: false
    markdown: |
      The point of this exercise is (1) to use string concatenation to display values with different types (`int` and `String`), and (2) to practice developing programs gradually by adding a few statements at a time.

      1.  Use the IDE on the left to write the answer to this exercise. Copy or type in something like the hello world program and make sure you can compile and run it.

          {Run!}(sh .guides/bg.sh javac code/Exercise_2_2.java java -cp code/ Exercise_2_2 )

      1.  Following the example in Section 2.4, write a program that creates variables named `day`, `date`, `month`, and `year`. The variable `day` will contain the day of the week (like Friday), and `date` will contain the day of the month (like the 13th). Assign values to those variables that represent today's date.

      1.  Display the value of each variable on a line by itself. This is an intermediate step that is useful for checking that everything is working so far. Compile and run your program before moving on.

          {Run!}(sh .guides/bg.sh javac code/Exercise_2_2.java java -cp code/ Exercise_2_2 2 )

      1.  Modify the program so that it displays the date in standard American format, for example: `Thursday, July 16, 2015`.

      1.  Modify the program so it also displays the date in European format. The final output should be:

      ```code
      American format:
      Thursday, July 16, 2015
      European format:
      Thursday 16 July 2015
      ```
  - name: Exercise 2.3
    type: section
    chapter: Variables and operators
    section: Exercises
    before: false
    markdown: |
      The point of this exercise is to (1) use some of the arithmetic operators, and (2) start thinking about compound entities (like time of day) that are represented with multiple values.


      1.  Use the IDE on the left to write the answer to this exercise. From now on, we won't remind you to start with a small, working program, but you should.

          {Run!}(sh .guides/bg.sh javac code/Exercise_2_3.java java -cp code/ Exercise_2_3 )

      1.  Following the example program in Section 2.4, create variables named `hour`, `minute`, and `second`.
          Assign values that are roughly the current time.
          Use a 24-hour clock so that at 2pm the value of `hour` is 14.

      1.  Make the program calculate and display the number of seconds since midnight.

      1.  Calculate and display the number of seconds remaining in the day.

      1.  Calculate and display the percentage of the day that has passed.
          You might run into problems when computing percentages with integers, so consider using floating-point.

      1.  Change the values of `hour`, `minute`, and `second` to reflect the current time.
          Then write code to compute the elapsed time since you started working on this exercise.


      *Hint:* You might want to use additional variables to hold values during the computation. Variables that are used in a computation but never displayed are sometimes called “intermediate” or “temporary” variables.
#Chapter 3
  - name: Exercise 3.1
    type: section
    chapter: Input and output
    section: Exercises
    before: false
    markdown: |
      When you use `printf`, the Java compiler does not check your format string.

      {Run!}(sh .guides/bg.sh javac code/Exercise_3_1.java java -cp code/ Exercise_3_1 )

      {Submit Answer!|assessment}(multiple-choice-4268363025)

      {Submit Answer!|assessment}(multiple-choice-1183993682)

      {Submit Answer!|assessment}(multiple-choice-4125459234)

      {Run!}(sh .guides/bg.sh javac code/Exercise_3_1.java java -cp code/ Exercise_3_1 2)
  - name: Exercise 3.2
    type: section
    chapter: Input and output
    section: Exercises
    before: false
    markdown: |
      Write a program that converts a temperature from Celsius to Fahrenheit. It should (1) prompt the user for input, (2) read a `double` value from the keyboard, (3) calculate the result, and (4) format the output to one decimal place. For example, it should display `"24.0 C = 75.2 F"`.

      Here is the formula. Be careful not to use integer division!
      $ F = C \times \frac{9}{5} + 32 $

      {Test it! | terminal}(javac code/CtoF.java && java -cp code/ CtoF)

      {Submit Answer!|assessment}(code-output-compare-167464931)
  - name: Exercise 3.3
    type: section
    chapter: Input and output
    section: Exercises
    before: false
    markdown: |
      Write a program that converts a total number of seconds to hours, minutes, and seconds. It should (1) prompt the user for input, (2) read an integer from the keyboard, (3) calculate the result, and (4) use `printf` to display the output. For example, `"5000 seconds = 1 hours, 23 minutes, and 20 seconds"`.

      *Hint:* Use the remainder operator.

      {Run! | terminal}(javac code/TimeConv.java && java -cp code/ TimeConv)

      {Submit Answer!|assessment}(code-output-compare-1034781984)
  - name: Exercise 3.4
    type: section
    chapter: Input and output
    section: Exercises
    before: false
    markdown: |
      The goal of this exercise is to program a “Guess My Number” game. When it's finished, it will work like this:

      ```code
      I'm thinking of a number between 1 and 100
      (including both). Can you guess what it is?
      Type a number: 45
      Your guess is: 45
      The number I was thinking of is: 14
      You were off by: 31
      ```

      To choose a random number, you can use the `Random` class in `java.util`. Check out the `GuessStarter` code in the left panel to see how it works.

      Like the `Scanner` class we saw in this chapter, `Random` has to be imported before we can use it. And as we saw with `Scanner`, we have to use the `new` operator to create a `Random` (number generator).

      Then we can use the method `nextInt` to generate a random number. In this example, the result of `nextInt(100)` will be between 0 and 99, including both. Adding 1 yields a number between 1 and 100, including both.



      1.  Checkout the definition of `GuessStarter` in a file called `GuessStarter.java` (on the left).

      1.  Compile and run this program.

          {Run! | terminal}(javac code/ch03/GuessStarter.java && java -cp code/ch03 GuessStarter)

      1.  Modify the program to prompt the user, then use a `Scanner` to read a line of user input.
          Compile and test the program.

      1.  Read the user input as an integer and display the result.
          Again, compile and test.

      1.  Compute and display the difference between the user's guess and the number that was generated.
#Chapter 4
  - name: Exercise 4.1
    type: section
    chapter: Methods and testing
    section: Exercises
    before: false
    markdown: |
      The purpose of this exercise is to take code from a previous exercise and redesign it as a method that takes parameters.

      1.  Use `Scanner` to ask the user for the `day`, `date`, `month`, and `year`.

      1.  Write a method called `printAmerican` that takes the day, date, month and year as parameters and that displays them in American format.

      1.  Test your method by invoking it from `main` and passing appropriate arguments.
          The output should look something like this (except that the date might be different):

          ```code
          Saturday, July 22, 2015
          ```

      1.  Once you have debugged `printAmerican`, write another method called `printEuropean` that displays the date in European format.

      {Test it! | terminal}(javac code/Exercise_2_2.java && java -cp code/ Exercise_2_2)

      {Check It!|assessment}(code-output-compare-1512412783)
  - name: Exercise 4.2
    type: section
    chapter: Methods and testing
    section: Exercises
    before: false
    markdown: |
      This exercise reviews the flow of execution through a program with multiple methods. Read the code to the left and answer the questions. [Get some help by using the visualizer](open_tutor code/Exercise_4_2.java panel=0)

      1. {Check It!|assessment}(fill-in-the-blanks-2152552529)

      1. {Check It!|assessment}(fill-in-the-blanks-182016295)

      1. {Check It!|assessment}(fill-in-the-blanks-3375902994)

      1. {Check It!|assessment}(fill-in-the-blanks-3371088969)
  - name: Exercise 4.3
    type: section
    chapter: Methods and testing
    section: Exercises
    before: false
    markdown: |
      Answer the following questions without running the program on a computer.

      Draw a stack diagram that shows the state of the program the first time `ping` is invoked.

      ```code
      public static void zoop() {
          baffle();
          System.out.print("You wugga ");
          baffle();
      }

      public static void main(String[] args) {
          System.out.print("No, I ");
          zoop();
          System.out.print("I ");
          baffle();
      }

      public static void baffle() {
          System.out.print("wug");
          ping();
      }

      public static void ping() {
          System.out.println(".");
      }
      ```

      {Check It!|assessment}(fill-in-the-blanks-1395462419)
  - name: Exercise 4.4
    type: section
    chapter: Methods and testing
    section: Exercises
    before: false
    markdown: |
      If you have a question about whether something is legal, and what happens if it is not, a good way to find out is to ask the compiler.
      Answer the following questions by trying them out.

      1.  {Submit Answer!|assessment}(free-text-3715087313)

      1.  {Submit Answer!|assessment}(free-text-2841236582)


      {Run!}(sh .guides/bg.sh javac code/Exercise_4_4.java java -cp code/ Exercise_4_4 )
  - name: Exercise 4.5
    type: section
    chapter: Methods and testing
    section: Exercises
    before: false
    markdown: |
      Draw a stack diagram that shows the state of the program the *second* time `zoop` is invoked.

      {Check It!|assessment}(parsons-puzzle-3212186746)


      ```code
      public static void zoop(String fred, int bob) {
          System.out.println(fred);
          if (bob == 5) {
              ping("not ");
          } else {
              System.out.println("!");
          }
      }

      public static void main(String[] args) {
          int bizz = 5;
          int buzz = 2;
          zoop("just for", bizz);
          clink(2 * buzz);
      }

      public static void clink(int fork) {
          System.out.print("It's ");
          zoop("breakfast ", fork);
      }

      public static void ping(String strangStrung) {
          System.out.println("any " + strangStrung + "more ");
      }
      ```
  - name: Exercise 4.6
    type: section
    chapter: Methods and testing
    section: Exercises
    before: false
    markdown: |
      Many computations can be expressed more concisely using the “multadd” operation, which takes three operands and computes `a * b + c`.
      Some processors even provide a hardware implementation of this operation for floating-point numbers.

      {Run!}(sh .guides/bg.sh javac code/Exercise_4_6.java java -cp code/ Exercise_4_6 )

      1.  Create a new program called `Multadd.java`.

      1.  Write a method called `multadd` that takes three `doubles` as parameters and that returns `a * b + c`.

      1.  Write a `main` method that tests `multadd` by invoking it with a few simple parameters, like `1.0, 2.0, 3.0`.

      1.  Also in `main`, use `multadd` to compute the following values:
      $$
      \sin \frac{\pi}{4} + \frac{\cos \frac{\pi}{4}}{2}
      $$

      $$
      \log 10 + \log 20
      $$

      1.  Write a method called `expSum` that takes a double as a parameter and that uses `multadd` to calculate:
      $$
      x e^{-x} + \sqrt{1 - e^{-x}}
      $$
      *Hint:* The method for raising $e$ to a power is `Math.exp`.


      In the last part of this exercise, you need to write a method that invokes another method you wrote. Whenever you do that, it is a good idea to test the first method carefully before working on the second. Otherwise, you might find yourself debugging two methods at the same time, which can be difficult.

      One of the purposes of this exercise is to practice pattern-matching: the ability to recognize a specific problem as an instance of a general category of problems.

#Chapter 5
  - name: Exercise 5.1
    type: section
    chapter: Conditionals and logic
    section: Exercises
    before: false
    markdown: |
      Using the following variables, evaluate the logic expressions in the table below.
      Write your answers as true, false, or error.

      ```code
      boolean yes = true;
      boolean no = false;
      int loVal = -999;
      int hiVal = 999;
      double grade = 87.5;
      double amount = 50.0;
      String hello = "world";
      ```


      |Expression|Result |
      |-|-|
      |`yes == no &#124;&#124; grade > amount`| |
      |`amount == 40.0 &#124;&#124; 50.0`| |
      |`hiVal != loVal &#124;&#124; loVal < 0`| |
      |`True &#124;&#124; hello.length() > 0`| |
      |`hello.isEmpty() && yes`| |
      |`grade <= 100 && !false`| |
      |`!yes &#124;&#124; no`| |
      |`grade > 75 > amount`| |
      |`amount <= hiVal && amount >= loVal`| |
      |`no && !no &#124;&#124; yes && !yes`| |
  - name: Exercise 5.2
    type: section
    chapter: Conditionals and logic
    section: Exercises
    before: false
    markdown: |
      ```code
      public static void main(String[] args) {
          boolean flag1 = isHoopy(202);
          boolean flag2 = isFrabjuous(202);
          System.out.println(flag1);
          System.out.println(flag2);
          if (flag1 && flag2) {
              System.out.println("ping!");
          }
          if (flag1 || flag2) {
              System.out.println("pong!");
          }
      }

      public static boolean isHoopy(int x) {
          boolean hoopyFlag;
          if (x % 2 == 0) {
              hoopyFlag = true;
          } else {
              hoopyFlag = false;
          }
          return hoopyFlag;
      }

      public static boolean isFrabjuous(int x) {
          boolean frabjuousFlag;
          if (x > 0) {
              frabjuousFlag = true;
          } else {
              frabjuousFlag = false;
          }
          return frabjuousFlag;
      }
      ```

      {Check It!|assessment}(parsons-puzzle-1092028033)


      The purpose of this exercise is to make sure you understand logical operators and the flow of execution through methods.
  - name: Exercise 5.3
    type: section
    chapter: Conditionals and logic
    section: Exercises
    before: false
    markdown: |
      {Check It!|assessment}(fill-in-the-blanks-2416765379)
  - name: Exercise 5.4
    type: section
    chapter: Conditionals and logic
    section: Exercises
    before: false
    markdown: |
      Fermat's Last Theorem says that there are no integers $a$, $b$, and $c$ such that $a^n + b^n = c^n$, except when $n \leq 2$.

      Write a program named `Fermat.java` that inputs four integers (`a`, `b`, `c`, and `n`) and checks to see if Fermat's theorem holds.
      If $n$ is greater than 2 and $a^n + b^n = c^n$, the program should display “Holy smokes, Fermat was wrong!”
      Otherwise the program should display “No, that doesn't work.”

      *Hint:* You may want to use `Math.pow`.

      {Run! | terminal}(javac code/Fermat.java && java -cp code/ Fermat)
  - name: Exercise 5.5
    type: section
    chapter: Conditionals and logic
    section: Exercises
    before: false
    markdown: |
      Now that we have conditional statements, we can get back to the “Guess My Number” game.

      You should already have a program that chooses a random number, prompts the user to guess it, and displays the difference between the guess and the chosen number.

      Adding a small amount of code at a time, and testing as you go, modify the program so it tells the user whether the guess is too high or too low, and then prompts the user for another guess.

      The program should continue until the user gets it right or guesses incorrectly three times.
      If the user guesses the correct number, display a message and terminate the program.

      {Run! | terminal}(javac code/ch03/GuessStarter.java && java -cp code/ch03 GuessStarter)
  - name: Exercise 5.6
    type: section
    chapter: Conditionals and logic
    section: Exercises
    before: false
    markdown: |
      Write a program named `Quadratic.java` that finds the roots of $ax^2 + bx + c = 0$ using the quadratic formula:
      $$ x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$
      Prompt the user to input integers for $a$, $b$, and $c$.
      Compute the two solutions for $x$, and display the results.

      Your program should be able to handle inputs for which there is only one or no solution.
      Specifically, it should not divide by zero or take the square root of a negative number.

      Be sure to validate all inputs.
      The user should never see an input mismatch exception.
      Display specific error messages that include the invalid input.

      {Test it! | terminal}(javac code/Quadratic.java && java -cp code/ch03 Quadratic)

      {Check It!|assessment}(code-output-compare-3676762189)
  - name: Exercise 5.7
    type: section
    chapter: Conditionals and logic
    section: Exercises
    before: false
    markdown: |
      If you are given three sticks, you may or may not be able to arrange them in a triangle.
      For example, if one of the sticks is 12 inches long and the other two are one inch long, you will not be able to get the short sticks to meet in the middle.
      For any three lengths, there is a simple test to see if it is possible to form a triangle:

      > If any of the three lengths is greater than the sum of the other two, you cannot form a triangle.

      Write a program named `Triangle.java` that inputs three integers, and then outputs whether you can (or cannot) form a triangle from the given lengths (outputting either "Yes" or "No"). Reuse your code from the previous exercise to validate the inputs. Display an error if any of the lengths are negative or zero.

      {Run! | terminal}(javac code/Triangle.java && java -cp code/ Triangle)

      {Check It!|assessment}(code-output-compare-4068291909)
      
#Chapter 6 
  - name: Exercise 6.1
    type: section
    chapter: Loops and strings
    section: Exercises
    before: false
    markdown: |
      Consider the following methods:

      ```code
      public static void main(String[] args) {
          loop(10);
      }

      public static void loop(int n) {
          int i = n;
          while (i > 1) {
              System.out.println(i);
              if (i % 2 == 0) {
                  i = i / 2;
              } else {
                  i = i + 1;
              }
          }
      }
      ```

      1.  Draw a table that shows the value of the variables `i` and `n` during the execution of `loop`. The table should contain one column for each variable and one line for each iteration.

      1.  {Check It!|assessment}(fill-in-the-blanks-1059885000)

      1.  Can you prove that this loop terminates for any positive value of `n`?
  - name: Exercise 6.2
    type: section
    chapter: Loops and strings
    section: Exercises
    before: false
    markdown: |
      Let's say you are given a number, $a$, and you want to find its square root. One way to do that is to start with a rough guess about the answer, $x_0$, and then improve the guess using this formula:

      $ x_1 =(x_0 + a/x_0) / 2 $

      For example, if we want to find the square root of 9, and we start with $x_0 = 6$, then $x_1 = (6 + 9/6) / 2 = 3.75$, which is closer. We can repeat the procedure, using $x_1$ to calculate $x_2$, and so on. In this case, $x_2 = 3.075$ and $x_3 = 3.00091$. So it converges quickly on the correct answer.

      Write a method called `squareRoot` that takes a `double` and returns an approximation of the square root of the parameter, using this technique. You should not use `Math.sqrt`.

      As your initial guess, you should use $a/2$. Your method should iterate until it gets two consecutive estimates that differ by less than 0.0001. You can use `Math.abs` to calculate the absolute value of the difference.

      {Run!}(sh .guides/bg.sh javac code/Exercise_6_2.java java -cp code/ Exercise_6_2 )
  - name: Exercise 6.3
    type: section
    chapter: Loops and strings
    section: Exercises
    before: false
    markdown: |
      One way to evaluate $\exp(-x^2)$ is to use the infinite series expansion:

      $ \exp(-x^2) = 1 - x^2 + x^4/2 - x^6/6 + \ldots $

      The $i$th term in this series is $(-1)^i x^{2i} / i!$. Write a method named `gauss` that takes `x` and `n` as arguments and returns the sum of the first `n` terms of the series. You should not use `factorial` or `pow`.

      {Run!}(sh .guides/bg.sh javac code/Exercise_6_2.java java -cp code/ Exercise_6_2 )
  - name: Exercise 6.4
    type: section
    chapter: Loops and strings
    section: Exercises
    before: false
    markdown: |
      A word is said to be “abecedarian” if the letters in the word appear in alphabetical order. For example, the following are all six-letter English abecedarian words:

      > abdest, acknow, acorsy, adempt, adipsy, agnosy, befist, behint, 
      > beknow, bijoux, biopsy, cestuy, chintz, deflux, dehors, dehort, 
      > deinos, diluvy, dimpsy 

      Write a method called `isAbecedarian` that takes a `String` and returns a `boolean` indicating whether the word is abecedarian.

      {Test it! | terminal}(javac code/Exercise_6_4.java && java -cp code/ Exercise_6_4)

      {Submit It!|assessment}(code-output-compare-1622713340)
  - name: Exercise 6.5
    type: section
    chapter: Loops and strings
    section: Exercises
    before: false
    markdown: |
      A word is said to be a “doubloon” if every letter that appears in the word appears exactly twice.
      Here are some example doubloons found in the dictionary:

      > Abba, Anna, appall, appearer, appeases, arraigning, beriberi, bilabial, boob, Caucasus, coco, Dada, deed, Emmett, Hannah, horseshoer, intestines, Isis, mama, Mimi, murmur, noon, Otto, papa, peep, reappear, redder, sees, Shanghaiings, Toto

      Write a method called `isDoubloon` that takes a string and checks whether it is a doubloon. To ignore case, invoke the `toLowerCase` method before checking.

      {Test It! | terminal}(javac code/Exercise_6_5.java && java -cp code/ Exercise_6_5)

      {Submit It!|assessment}(code-output-compare-4088069480)
  - name: Exercise 6.6
    type: section
    chapter: Loops and strings
    section: Exercises
    before: false
    markdown: |
      In Scrabble each player has a set of tiles with letters on them. The object of the game is to use those letters to spell words. The scoring system is complex, but longer words are usually worth more than shorter words.

      Imagine you are given your set of tiles as a string, like `"quijibo"`, and you are given another string to test, like `"jib"`.

      Write a method called `canSpell` that takes two strings and checks whether the set of tiles can spell the word. You might have more than one tile with the same letter, but you can only use each tile once.

      {Test it! | terminal}(javac code/Exercise_6_6.java && java -cp code/ Exercise_6_6)

      {Submit It!|assessment}(code-output-compare-2674729083)


      *Scrabble is a registered trademark owned in the USA and Canada by Hasbro Inc., and in the rest of the world by J.\ W.\ Spear \& Sons Limited of Maidenhead, Berkshire, England, a subsidiary of Mattel Inc.*

#Chapter 7
  - name: Exercise 7.1
    type: section
    chapter: Arrays and references
    section: Exercises
    before: false
    markdown: |
      The purpose of this exercise is to practice reading code and recognizing the traversal patterns in this chapter. The following methods are hard to read, because instead of using meaningful names for the variables and methods, they use names of fruit.

      {Check It!|assessment}(free-text-392795339)

      {Check It!|assessment}(free-text-261081027)

      {Check It!|assessment}(free-text-2731721699)
  - name: Exercise 7.2
    type: section
    chapter: Arrays and references
    section: Exercises
    before: false
    markdown: |
      {Check It!|assessment}(free-text-3840556776)
  - name: Exercise 7.3
    type: section
    chapter: Arrays and references
    section: Exercises
    before: false
    markdown: |
      Write a method called `indexOfMax` that takes an array of integers and returns the index of the largest element.

      {Run!}(sh .guides/bg.sh javac code/IndexOfMax.java java -cp code/ IndexOfMax )

      {Check It!|assessment}(multiple-choice-3241266919)

      {Check It!|assessment}(free-text-3730081442)
  - name: Exercise 7.4
    type: section
    chapter: Arrays and references
    section: Exercises
    before: false
    markdown: |
      The Sieve of Eratosthenes is “a simple, ancient algorithm for finding all prime numbers up to any given limit,” which you can read about at [https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes).

      Write a method called `sieve` that takes an integer parameter, `n`, and returns a `boolean` array that indicates, for each number from `0` to `n - 1`, whether the number is prime.

      {Run!}(sh .guides/bg.sh javac code/Sieve.java java -cp code/ Sieve )
  - name: Exercise 7.5
    type: section
    chapter: Arrays and references
    section: Exercises
    before: false
    markdown: |
      Write a method named `areFactors` that takes an integer `n` and an array of integers, and that returns `true` if the numbers in the array are all factors of `n` (which is to say that `n` is divisible by all of them).

      {Test It! | terminal}(javac code/Exercise_7_5.java && java -cp code/ Exercise_7_5)

      {Submit It!|assessment}(code-output-compare-2616825575)
  - name: Exercise 7.6
    type: section
    chapter: Arrays and references
    section: Exercises
    before: false
    markdown: |
      Write a method named `arePrimeFactors` that takes an integer `n` and an array of integers, and that returns `true` if the numbers in the array are all prime *and* their product is `n`.

      {Run! | terminal}(javac code/Exercise_7_6.java && java -cp code/ Exercise_7_6)
  - name: Exercise 7.7
    type: section
    chapter: Arrays and references
    section: Exercises
    before: false
    markdown: |
      Write a method called `letterHist` that takes a string as a parameter and returns a histogram of the letters in the string. The zeroth element of the histogram should contain the number of a's in the string (upper- and lowercase); the 25th element should contain the number of z's. Your solution should only traverse the string once.

      {Run! | terminal}(javac code/Exercise_7_7.java && java -cp code/ Exercise_7_7)
  - name: Exercise 7.8
    type: section
    chapter: Arrays and references
    section: Exercises
    before: false
    markdown: |
      Two words are anagrams if they contain the same letters and the same number of each letter. For example, “stop” is an anagram of “pots” and “allen downey” is an anagram of “well annoyed”. Write a method that takes two strings and checks whether they are anagrams of each other.

      {Run! | terminal}(javac code/Anagrams.java && java -cp code/ Anagrams)

      {Check It!|assessment}(code-output-compare-1428839038)

#Chapter 8
  - name: Exercise 8.1
    type: section
    chapter: Recursive methods
    section: Exercises
    before: false
    markdown: |
      The purpose of this exercise is to take a problem and break it into smaller problems, and to solve the smaller problems by writing simple methods.
      Consider the first verse of the song “99 Bottles of Beer”:

      > 99 bottles of beer on the wall,<br/>
      > 99 bottles of beer,<br/>
      > ya' take one down, ya' pass it around,<br/>
      > 98 bottles of beer on the wall.

      Subsequent verses are identical except that the number of bottles gets smaller by one in each verse, until the last verse:

      > No bottles of beer on the wall,<br/>
      > no bottles of beer,<br/>
      > ya' can't take one down, ya' can't pass it around,<br/>
      > 'cause there are no more bottles of beer on the wall!

      And then the song (finally) ends.

      Write a program that displays the entire lyrics of “99 Bottles of Beer”. Your program should include a recursive method that does the hard part, but you might want to write additional methods to separate other parts of the program. As you develop your code, test it with a small number of verses, like `3`.

      {Test it! | terminal}(javac code/Exercise_8_1.java && java -cp code/ Exercise_8_1)

      {Submit It!|assessment}(code-output-compare-436735314)
  - name: Exercise 8.2
    type: section
    chapter: Recursive methods
    section: Exercises
    before: false
    markdown: |
      Write a recursive method named `oddSum` that takes a positive odd integer `n` and returns the sum of odd integers from 1 to n. Start with a base case, and use temporary variables to debug your solution. You might find it helpful to print the value of `n` each time `oddSum` is invoked.

      {Test It! | terminal}(javac code/Exercise_8_2.java && java -cp code/ Exercise_8_2)

      {Submit It!|assessment}(code-output-compare-1415874548)

  - name: Exercise 8.3
    type: section
    chapter: Recursive methods
    section: Exercises
    before: false
    markdown: |
      In this exercise, you will use a stack diagram to understand the execution of the following recursive method.

      ```code
      public static void main(String[] args) {
          System.out.println(prod(1, 4));
      }

      public static int prod(int m, int n) {
          if (m == n) {
              return n;
          } else {
              int recurse = prod(m, n - 1);
              int result = n * recurse;
              return result;
          }
      }
      ```

      1.  Draw a stack diagram showing the state of the program just before the last invocation of `prod` completes.

      1.  What is the output of this program? (Try to answer this question on paper first, then run the code to check your answer.)

          {Run!}(sh .guides/bg.sh javac code/Exercise_8_3.java java -cp code/ Exercise_8_3 )

      1.  Explain in a few words what `prod` does (without getting into the details of how it works).

      1.  Rewrite `prod` without the temporary variables `recurse` and `result`.
      *Hint:* You only need one line for the `else` branch.
  - name: Exercise 8.4
    type: section
    chapter: Recursive methods
    section: Exercises
    before: false
    markdown: |
      The goal of this exercise is to translate a recursive definition into a Java method.
      The Ackermann function is defined for non-negative integers as follows:
      $$
      A(m, n) = \begin{cases}
                    n+1 & \mbox{if } m = 0 \\
              A(m-1, 1) & \mbox{if } m > 0 \mbox{ and } n = 0 \\
      A(m-1, A(m, n-1)) & \mbox{if } m > 0 \mbox{ and } n > 0
      \end{cases}
      $$

      Write a recursive method called `ack` that takes two `int`s as parameters and that computes and returns the value of the Ackermann function.

      Test your implementation of Ackermann by invoking it from `main` and displaying the return value. Note the return value gets very big very quickly. You should try it only for small values of $m$ and $n$ (not bigger than 3).

      {Test it! | terminal}(javac code/Exercise_8_4.java && java -cp code/ Exercise_8_4)

      {Submit It!|assessment}(code-output-compare-160671833)
  - name: Exercise 8.5
    type: section
    chapter: Recursive methods
    section: Exercises
    before: false
    markdown: |
      Write a recursive method called `power` that takes a double `x` and an integer `n` and returns $x^n$.

      *Hint:* A recursive definition of this operation is $x^n = x \cdot x^{n-1}$.
      Also, remember that anything raised to the zeroth power is 1.

      Optional challenge: you can make this method more efficient, when `n` is even, using $x^n = \left( x^{n/2} \right)^2$.

      {Test it! | terminal}(javac code/Exercise_8_5.java && java -cp code/ Exercise_8_5)

      {Submit It!|assessment}(code-output-compare-565198109)
  - name: Exercise 8.6
    type: section
    chapter: Recursive methods
    section: Exercises
    before: false
    markdown: |
      Many of the patterns we have seen for traversing arrays can also be written recursively. It is not common, but it is a useful exercise.

      1.  Write a method called `maxInRange` that takes an array of integers and two indexes, `lowIndex` and `highIndex`, and finds the maximum value in the array, but only considering the elements between `lowIndex` and `highIndex`, including both.

      This method should be recursive. If the length of the range is 1, that is, if `lowIndex == highIndex`, we know immediately that the sole element in the range must be the maximum. So that's the base case.

      If there is more than one element in the range, we can break the array into two pieces, find the maximum in each of the pieces, and then find the maximum of the maxima.

      1.  Methods like `maxInRange` can be awkward to use.
          To find the largest element in an array, we have to provide the range for the entire array.

      ```code
      double max = maxInRange(a, 0, a.length - 1);
      ```

      Write a method called `max` that takes an array and uses `maxInRange` to find and return the largest element.

      {Run!}(sh .guides/bg.sh javac code/Exercise_8_6.java java -cp code/ Exercise_8_6 )
  - name: Exercise 8.7
    type: section
    chapter: Recursive methods
    section: Exercises
    before: false
    markdown: |
      Create a program called `Recurse.java` and type in the following methods:

      ```code
      /**
       * Returns the first character of the given String.
       */
      public static char first(String s) {
          return s.charAt(0);
      }

      /**
       * Returns all but the first letter of the given String.
       */
      public static String rest(String s) {
          return s.substring(1);
      }

      /**
       * Returns all but the first and last letter of the String.
       */
      public static String middle(String s) {
          return s.substring(1, s.length() - 1);
      }

      /**
       * Returns the length of the given String.
       */
      public static int length(String s) {
          return s.length();
      }
      ```



      1.  Write some code in `main` that tests each of these methods. Make sure they work, and you understand what they do.

          {Run!}(sh .guides/bg.sh javac code/Recurse.java java -cp code/ Recurse )

      1.  Using these methods, and without using any other `String` methods, write a method called `printString` that takes a string as a parameter and that displays the letters of the string, one on each line. It should be a void method.

      1.  Again using only these methods, write a method called `printBackward` that does the same thing as `printString` but that displays the string backward (again, one character per line).

      1.  Now write a method called `reverseString` that takes a string as a parameter and that returns a new string as a return value. The new string should contain the same letters as the parameter, but in reverse order.

          ```code
          String backwards = reverseString("coffee");
          System.out.println(backwards);
          ```

          The output of this example code should be:

          ```code
          eeffoc
          ```

      1.  A palindrome is a word that reads the same both forward and backward, like “otto” and “palindromeemordnilap”. Here's one way to test whether a string is a palindrome:

          > A single letter is a palindrome, a two-letter word is a palindrome if the letters are the same, and any other word is a palindrome if the first letter is the same as the last and the middle is a palindrome.

          Write a recursive method named `isPalindrome` that takes a `String` and returns a `boolean` indicating whether the word is a palindrome.

#Chapter 9
  - name: Exercise 9.1
    type: section
    chapter: Immutable objects
    section: Exercises
    before: false
    markdown: |
      The point of this exercise is to explore Java types and fill in some of the details that aren't covered in the chapter.

      1.  Create a new program named `Test.java` and write a `main` method that contains expressions that combine various types using the `+` operator.
          For example, what happens when you “add” a `String` and a `char`?
          Does it perform character addition or string concatenation?
          What is the type of the result?
          (How can you determine the type of the result?)

          {Run!}(sh .guides/bg.sh javac code/Test.java java -cp code/ Test )

      1.  Make a bigger copy of the following table and fill it in.
          At the intersection of each pair of types, you should indicate whether it is legal to use the `+` operator with these types, what operation is performed (addition or concatenation), and what the type of the result is.

          |&  boolean |  char  |  ~int ~ | double | String <br/> \hline|
          |-|-|-|-|-|
          |boolean|         |        |         |        |        <br/> \hline|
          |char   |         |        |         |        |        <br/> \hline|
          |int    |         |        |         |        |        <br/> \hline|
          |double |         |        |         |        |        <br/> \hline|
          |String |         |        |         |        |        <br/> \hline|


      1.  Think about some of the choices the designers of Java made, based on this table. How many of the entries seem unavoidable, as if there was no other choice? How many seem like arbitrary choices from several equally reasonable possibilities? Which entries seem most problematic?

      1.  Here's a puzzler: normally, the statement `x++` is exactly equivalent to `x = x + 1`. But if `x` is a `char`, it's not exactly the same! In that case, `x++` is legal, but `x = x + 1` causes an error. Try it out and see what the error message is, then see if you can figure out what is going on.

      1.  What happens when you add `""` (the empty string) to the other types, for example, `"" + 5`?
  - name: Exercise 9.2
    type: section
    chapter: Immutable objects
    section: Exercises
    before: false
    markdown: |
      The goal of this exercise is to practice encapsulation and generalization using some of the examples in previous chapters.

      1.  Starting with the code in Section 7.5, write a method called `powArray` that takes a `double` array, `a`, and returns a new array that contains the elements of `a` squared. Generalize it to take a second argument and raise the elements of `a` to the given power.

          {Run!}(sh .guides/bg.sh javac code/CopyingArrays.java java -cp code/ CopyingArrays )

      1.  Starting with the code in Section 7.8, write a method called `histogram` that takes an `int` array of scores from 0 to (but not including) 100, and returns a histogram of 100 counters. Generalize it to take the number of counters as an argument.

          {Run!}(sh .guides/bg.sh javac code/Histogram.java java -cp code/ Histogram )
  - name: Exercise 9.3
    type: section
    chapter: Immutable objects
    section: Exercises
    before: false
    markdown: |
      You might be sick of the factorial method by now, but we're going to do one more version.

      1.  Create a new program called `Big.java` and write an iterative version of `factorial` (using a `for` loop)

          {Run!}(sh .guides/bg.sh javac code/Big.java java -cp code/ Big )

      1.  Display a table of the integers from 0 to 30 along with their factorials.
          At some point around 15, you will probably see that the answers are not correct anymore.
          Why not?

      1.  Convert `factorial` so that it performs its calculation using BigIntegers and returns a `BigInteger` as a result. You can leave the parameter alone; it will still be an integer.

      1.  Try displaying the table again with your modified factorial method.
          Is it correct up to 30?
          How high can you make it go?
  - name: Exercise 9.4
    type: section
    chapter: Immutable objects
    section: Exercises
    before: false
    markdown: |
      Many encryption algorithms depend on the ability to raise large integers to a power. Here is a method that implements an efficient algorithm for integer exponentiation:

      ```code
      public static int pow(int x, int n) {
          if (n == 0) return 1;

          // find x to the n/2 recursively
          int t = pow(x, n / 2);

          // if n is even, the result is t squared
          // if n is odd, the result is t squared times x
          if (n % 2 == 0) {
              return t * t;
          } else {
              return t * t * x;
          }
      }
      ```

      The problem with this method is that it only works if the result is small enough to be represented by an `int`. Rewrite it so that the result is a `BigInteger`. The parameters should still be integers, though.

      You should use the `BigInteger` methods `add` and `multiply`. But don't use `BigInteger.pow`; that would spoil the fun.

      {Run!}(sh .guides/bg.sh javac code/BigInteger2.java java -cp code/ BigInteger2 )
  - name: Exercise 9.5
    type: section
    chapter: Immutable objects
    section: Exercises
    before: false
    markdown: |
      One way to calculate $e^x$ is to use the following infinite series expansion.
      The $i$th term in the series is $x^i / i!$.
      $ e^x = 1 + x + x^2 / 2! + x^3 / 3! + x^4 / 4! + \ldots $


      1.  Write a method called `myexp` that takes `x` and `n` as parameters and estimates $e^x$ by adding the first `n` terms of this series. You can use the `factorial` method from Section 8.3 or your iterative version from the previous exercise.

          {Run!}(sh .guides/bg.sh javac code/Exercise_9_5.java java -cp code/ Exercise_9_5 )

      1.  You can make this method more efficient by observing that the numerator of each term is the same as its predecessor multiplied by `x`, and the denominator is the same as its predecessor multiplied by `i`.

          Use this observation to eliminate the use of `Math.pow` and `factorial`, and check that you get the same result.

      1.  Write a method called `check` that takes a parameter, `x`, and displays `x`, `myexp(x)`, and `Math.exp(x)`.
          The output should look something like:

          ```code
          1.0     2.708333333333333     2.718281828459045
          ```

          You can use the escape sequence `"<br/>t"` to put a tab character between columns of a table.

      1.  Vary the number of terms in the series (the second argument that `check` sends to `myexp`) and see the effect on the accuracy of the result. Adjust this value until the estimated value agrees with the correct answer when `x` is 1.

      1.  Write a loop in `main` that invokes `check` with the values 0.1, 1.0, 10.0, and 100.0. How does the accuracy of the result vary as `x` varies? Compare the number of digits of agreement rather than the difference between the actual and estimated values.

      1.  Add a loop in `main` that checks `myexp` with the values -0.1, -1.0, -10.0, and -100.0. Comment on the accuracy.
  - name: Exercise 9.6
    type: section
    chapter: Immutable objects
    section: Exercises
    before: false
    markdown: |
      The following code fragment traverses a string and checks whether it has the same number of open and close parentheses:

      ```code
      String s = "((3 + 7) * 2)";
      int count = 0;

      for (int i = 0; i < s.length(); i++) {
          char c = s.charAt(i);
          if (c == '(') {
              count++;
          } else if (c == ')') {
              count--;
          }
      }

      System.out.println(count);
      ```

      1.  Encapsulate this fragment in a method that takes a string argument and returns the final value of `count`.

          {Run!}(sh .guides/bg.sh javac code/Exercise_9_6.java java -cp code/ Exercise_9_6 )

      1.  Test your method with multiple strings, including some that are balanced and some that are not.

      1.  Generalize the code so that it works on any string. What could you do to generalize it more?
    
#Chapter 10 
  - name: Exercise 10.1
    type: section
    chapter: Mutable objects
    section: Exercises
    before: false
    markdown: |
      The point of this exercise is to make sure you understand the mechanism for passing objects as parameters.

      1.  For the following program, draw a stack diagram showing the local variables and parameters of `main` and `riddle` just before `riddle` returns.
          Use arrows to show which objects each variable references.

      1.  {Submit Answer!|assessment}(free-text-522877701)

      1.  {Submit Answer!|assessment}(free-text-897455674)



      ```code
      public static int riddle(int x, Point p) {
          x = x + 7;
          return x + p.x + p.y;
      }

      public static void main(String[] args) {
          int x = 5;
          Point blank = new Point(1, 2);

          System.out.println(riddle(x, blank));
          System.out.println(x);
          System.out.println(blank.x);
          System.out.println(blank.y);
      }
      ```
  - name: Exercise 10.2
    type: section
    chapter: Mutable objects
    section: Exercises
    before: false
    markdown: |
      The point of this exercise is to make sure you understand the mechanism for returning new objects from methods. The following code uses `findCenter` and `distance` as defined in this chapter.

      1.  Draw a stack diagram showing the state of the program just before `findCenter` returns. Include all variables and parameters, and show the objects those variables refer to.

      1.  Draw a stack diagram showing the state of the program just before `distance` returns. Show all variables, parameters, and objects.

      1.  {Submit Answer!|assessment}(free-text-3775858035)

      ```code
      public static void main(String[] args) {
          Point blank = new Point(5, 8);

          Rectangle rect = new Rectangle(0, 2, 4, 4);
          Point center = findCenter(rect);

          double dist = distance(center, blank);
          System.out.println(dist);
      }
      ```
  - name: Exercise 10.3
    type: section
    chapter: Mutable objects
    section: Exercises
    before: false
    markdown: |
      This exercise is about aliasing. Recall that aliases are two variables that refer to the same object. The following code uses `findCenter` and `printPoint` as defined in this chapter.

      1.  Draw a diagram that shows the state of the program just before the end of `main`. Include all local variables and the objects they refer to.

      1.  {Submit Answer!|assessment}(free-text-2190936241)

      1.  {Submit Answer!|assessment}(free-text-1542807523)


      ```code
      public static void main(String[] args) {
          Rectangle box1 = new Rectangle(2, 4, 7, 9);
          Point p1 = findCenter(box1);
          printPoint(p1);

          box1.grow(1, 1);
          Point p2 = findCenter(box1);
          printPoint(p2);
      }
      ```

#Chapter 11
  - name: Exercise 11.1
    type: section
    chapter: Designing classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex11.1

      Review the documentation of \java{java.awt.Rectangle}.
      Which methods are pure?
      Which are modifiers?

      If you review the documentation of \java{java.lang.String}, you should see that there are no modifiers, because strings are immutable.

      \end{exercise}
  - name: Exercise 11.2
    type: section
    chapter: Designing classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex11.2

      The implementation of \java{increment} in this chapter is not very efficient.
      Can you rewrite it so it doesn't use any loops?

      {\it Hint:} Remember the remainder operator. And yes, it works with \java{double}s too.

      \end{exercise}
  - name: Exercise 11.3
    type: section
    chapter: Designing classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex11.3
      \index{Scrabble}

      In the board game Scrabble, each tile contains a letter, which is used to spell words in rows and columns, and a score, which is used to determine the value of words.

      \begin{enumerate}

      \item Write a definition for a class named \java{Tile} that represents Scrabble tiles.
      The instance variables should include a character named \java{letter} and an integer named \java{value}.

      \item Write a constructor that takes parameters named \java{letter} and \java{value} and initializes the instance variables.

      \item Write a method named \java{printTile} that takes a \java{Tile} object as a parameter and displays the instance variables in a reader-friendly format.

      \item Write a method named \java{testTile} that creates a \java{Tile} object with the letter \java{Z} and the value \java{10}, and then uses \java{printTile} to display the state of the object.

      \item Implement the \java{toString} and \java{equals} methods for a \java{Tile}.

      \item Create getters and setters for each of the attributes.

      \end{enumerate}

      The point of this exercise is to practice the mechanical part of creating a new class definition.
      \end{exercise}
  - name: Exercise 11.4
    type: section
    chapter: Designing classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex11.4

      Write a class definition for \java{Date}, an object type that contains three integers: \java{year}, \java{month}, and \java{day}.
      This class should provide two constructors.
      The first should take no parameters and initialize a default date.
      The second should take parameters named \java{year}, \java{month} and \java{day}, and use them to initialize the instance variables.

      Write a \java{main} method that creates a new \java{Date} object named \java{birthday}.
      The new object should contain your birth date.
      You can use either constructor.
      %Compare your implementation to \java{java.util.Date}.

      \end{exercise}
  - name: Exercise 11.5
    type: section
    chapter: Designing classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex11.5

      \index{rational number}

      A rational number is a number that can be represented as the ratio of two integers.
      For example, $2/3$ is a rational number, and you can think of 7 as a rational number with an implicit 1 in the denominator.
      %The goal of this exercise is to write a class definition for rational numbers.

      \begin{enumerate}

      \item Define a class called \java{Rational}.
      A \java{Rational} object should have two integer instance variables that store the numerator and denominator.

      \item Write a constructor that takes no arguments and that sets the numerator to 0 and denominator to 1.

      \item Write an instance method called \java{printRational} that displays a \java{Rational} in some reasonable format.

      \item Write a \java{main} method that creates a new object with type \java{Rational}, sets its instance variables to some values, and displays the object.

      \item At this stage, you have a minimal testable program.
      Test it and, if necessary, debug it.

      \item Write a \java{toString} method for \java{Rational} and test it using \java{println}.

      \item Write a second constructor that takes two arguments and uses them to initialize the instance variables.

      \item Write an instance method called \java{negate} that reverses the sign of a rational number.
      This method should be a modifier, so it should be void.
      Add lines to \java{main} to test the new method.

      \item Write an instance method called \java{invert} that inverts the number by swapping the numerator and denominator.
      It should be a modifier.
      Add lines to \java{main} to test the new method.

      \item Write an instance method called \java{toDouble} that converts the rational number to a \java{double} (floating-point number) and returns the result.
      This method is a pure method; it does not modify the object.
      As always, test the new method.

      \item Write an instance method named \java{reduce} that reduces a rational number to its lowest terms by finding the greatest common divisor (GCD) of the numerator and denominator and dividing through.
      This method should be a pure method; it should not modify the instance variables of the object on which it is invoked.

      {\it Hint:} Finding the GCD only takes a few lines of code.
      Search the web for ``Euclidean algorithm''.

      \item Write an instance method called \java{add} that takes a \java{Rational} number as an argument, adds it to \java{this}, and returns a new \java{Rational} object.

      There are several ways to add fractions.
      You can use any one you want, but you should make sure that the result of the operation is reduced so that the numerator and denominator have no common divisor (other than 1).

      \end{enumerate}

      The purpose of this exercise is to write a class definition that includes a variety of methods, including constructors, static methods, instance methods, modifiers, and pure methods.

      \end{exercise}

#Chapter 12
  - name: Exercise 12.1
    type: section
    chapter: Arrays of objects
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex12.1

      Encapsulate the deck-building code from Section~\ref{cardarray} in a method called \java{makeDeck} that takes no parameters and returns a fully-populated array of \java{Card}s.

      \end{exercise}
  - name: Exercise 12.2
    type: section
    chapter: Arrays of objects
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex12.2

      In some card games, Aces are ranked higher than Kings.
      Modify the \java{compareTo} method to implement this ordering.

      \end{exercise}
  - name: Exercise 12.3
    type: section
    chapter: Arrays of objects
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex12.3

      In Poker a ``flush'' is a hand that contains five or more cards of the same suit.
      A hand can contain any number of cards.

      \index{histogram}

      \begin{enumerate}

      \item Write a method called \java{suitHist} that takes an array of cards as a parameter and that returns a histogram of the suits in the hand.
      Your solution should only traverse the array once.

      \item Write a method called \java{hasFlush} that takes an array of cards as a parameter and returns \java{true} if the hand contains a flush (and \java{false} otherwise).

      \end{enumerate}

      \end{exercise}
  - name: Exercise 12.4
    type: section
    chapter: Arrays of objects
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex12.4

      Working with cards is more interesting if you can display them on the screen.
      If you have not already read Appendix~\ref{graphics} about 2D graphics, you should read it before working on this exercise.
      In the code directory for this chapter, {\tt ch12}, you will find:

      \begin{itemize}

      \item {\tt cardset-oxymoron}: A directory containing images of playing cards.

      \item {\tt CardTable.java}: A sample program that demonstrates how to read and display images.

      \end{itemize}

      \index{array!2D}

      This code demonstrates the use of a 2D array, specifically an array of images.
      The declaration looks like this:

      \begin{code}
      private Image[][] images;
      \end{code}

      The variable \java{images} refers to a 2D array of \java{Image} objects, which are defined in the \java{java.awt} package.
      Here's the code that creates the array itself:

      \begin{code}
      images = new Image[14][4];
      \end{code}

      The array has 14 rows (one for each rank plus an unused row for rank 0) and 4 columns (one for each suit).
      Here's the loop that populates the array:

      \begin{code}
      String cardset = "cardset-oxymoron";
      String suits = "cdhs";

      for (int suit = 0; suit <= 3; suit++) {
          char c = suits.charAt(suit);

          for (int rank = 1; rank <= 13; rank++) {
              String s = String.format("%s/%02d%c.gif",
                                       cardset, rank, c);
              images[rank][suit] = new ImageIcon(s).getImage();
          }
      }
      \end{code}

      The variable \java{cardset} contains the name of the directory that contains the image files.
      \java{suits} is a string that contains the single-letter abbreviations for the suits.
      These strings are used to assemble \java{s}, which contains the filename for each image.
      For example, when \java{rank=1} and \java{suit=2}, the value of \java{s} is \java{"cardset-oxymoron/01h.gif"}, which is an image of the Ace of Hearts.

      The last line of the loop reads the image file, extracts an \java{Image} object, and assigns it to a location in the array, as specified by the indexes \java{rank} and \java{suit}.
      For example, the image of the Ace of Hearts is stored in row 1, column 2.

      If you compile and run {\tt CardTable.java}, you should see images of a deck of cards laid out on a green table.
      You can use this class as a starting place to implement your own card games.

      %TODO: We should make an actual exercise out of this.
      % Maybe take an array of cards and display them in a row at a given location?
      % Or we could make this a new section and emphasize the use of 2D arrays more.

      \end{exercise}

#Chapter 13
  - name: Exercise 13.1
    type: section
    chapter: Objects of arrays
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex13.5

      Write a \java{toString} method for the \java{Deck} class.
      It should return a single string that represents the cards in the deck.
      When it's printed, this string should display the same results as the \java{print} method in Section~\ref{deck}.

      \index{StringBuilder}
      \index{efficiency}

      {\it Hint:} You can use the \java{+} operator to concatenate strings, but it is not very efficient.
      Consider using \java{java.lang.StringBuilder} instead; you can review the documentation by doing a web search for ``Java StringBuilder''.

      \end{exercise}
  - name: Exercise 13.2
    type: section
    chapter: Objects of arrays
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex13.2
      \label{ex.shuffle}

      The goal of this exercise is to implement the shuffling algorithm from this chapter.

      \begin{enumerate}

      \item In the repository for this book, you should find the file named {\tt Deck.java}.
      Check that you can compile it in your environment.

      \item Implement the \java{randomInt} method.
      You can use the \java{nextInt} method provided by \java{java.util.Random}, which we saw in Section~\ref{random}.

      {\it Hint:} Avoid creating a \java{Random} object every time \java{randomInt} is invoked by defining a class variable.

      \item Implement the \java{swapCards} method that takes two indexes and swaps the cards at the given locations.

      \item Implement the \java{shuffle} method using the algorithm in Section~\ref{shuffle}.

      \end{enumerate}

      \end{exercise}
  - name: Exercise 13.3
    type: section
    chapter: Objects of arrays
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex13.3

      The goal of this exercise is to implement the sorting algorithms from this chapter.
      Use the {\tt Deck.java} file from the previous exercise, or create a new one from scratch.

      \begin{enumerate}

      \item Implement the \java{indexLowest} method.
      Use the \java{Card.compareTo} method to find the lowest card in a given range of the deck (from \java{lowIndex} to \java{highIndex}, including both).

      \item Implement \java{selectionSort} using the algorithm in Section~\ref{sorting}.

      \item Using the pseudocode in Section~\ref{mergesort}, implement the \java{merge} method.
      The best way to test it is to build and shuffle a deck.
      Then use \java{subdeck} to form two small subdecks, and use selection sort to sort them.
      Finally, pass the two halves to \java{merge} and see if it works.
      \index{testing}

      \item Implement \java{almostMergeSort}, the one that divides the deck in half, uses \java{selectionSort} to sort the two halves, and uses \java{merge} to create a new, sorted deck.
      You should be able to reuse code from the previous step.

      \item Implement \java{mergeSort} recursively.
      Remember that \java{selectionSort} is a modifier and \java{mergeSort} is a pure method, which means that they get invoked differently:

      \begin{code}
      deck.selectionSort();      // modifies an existing deck
      deck = deck.mergeSort();   // replaces old deck with new
      \end{code}

      \end{enumerate}

      \end{exercise}
  - name: Exercise 13.4
    type: section
    chapter: Objects of arrays
    section: Exercises
    before: false
    latex: |
      \begin{exercise}

      %%V6 Ex13.1
      You can learn more about the sorting algorithms in this chapter, and others, at \href{http://www.sorting-algorithms.com/}{sorting-algorithms.com}.
      This site provides explanations of the algorithms and animations that show how they work.
      It also includes an analysis of their efficiency.

      %%V6 Ex13.4
      For example, ``insertion sort'' is an algorithm that inserts elements into place, one at a time.
      Read about it at \url{http://www.sorting-algorithms.com/insertion-sort}.
      Then write a method named \java{insertionSort} that implements this algorithm.

      One goal of this exercise is to practice top-down design.
      Your solution should use a helper method, named \java{insert}, that implements the inner loop of the algorithm.
      \java{insertionSort} should invoke this method $n-1$ times.


      \end{exercise}
  - name: Exercise 13.5
    type: section
    chapter: Objects of arrays
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6.5 NEW

      Find and open the file \java{War.java} in the repository.
      The \java{main} method contains all the code from the last section of this chapter.
      Check that you can compile and run this code before proceeding.

      The program is incomplete; it does not handle the case when two cards have the same rank.
      Finish implementing the \java{main} method beginning at the line that says: \java{// it's a tie...draw four more cards}.

      When there's a tie, draw three cards from each pile and store them in a collection, along with the original two.
      Then draw one more card from each pile and compare them.
      Whoever wins the tie will take all ten of these cards.

      If one pile does not have at least four cards, the game ends immediately.
      If a tie ends with a tie, flip a coin and give the cards to one of the players.

      Notice that this program depends on \java{Deck.shuffle}.
      If you haven't implemented the \java{shuffle} method (see Exercise~\ref{ex.shuffle}), the game won't be that fun.
      Player 1 will have the Ace through King of the first two suits, and Player 2 will have the the Ace through King of the other two suits, all in the same order.

      \end{exercise}
  - name: Exercise 13.6
    type: section
    chapter: Objects of arrays
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6.5 NEW

      Extend your program from the previous exercise to handle the case when a tie ends with a tie.
      In other words, when the fourth cards have the same rank, add three more cards to the collection and try again.
      You will need to wrap your code in a loop, for example: \java{while (diff == 0)}.

      \end{exercise}

#Chapter 14
  - name: Exercise 14.1
    type: section
    chapter: Extending classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex14.1

      Design a better strategy for the \java{Player.play} method.
      For example, if there are multiple cards you can play, and one of them is an eight, you might want to play the eight.

      \index{override}

      Think of other ways you can minimize penalty points, such as playing the highest-ranking cards first.
      Write a new class that extends \java{Player} and overrides \java{play} to implement your strategy.

      \end{exercise}
  - name: Exercise 14.2
    type: section
    chapter: Extending classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex14.2

      Write a loop that plays the game 100 times and keeps track of how many times each player wins.
      If you implemented multiple strategies in the previous exercise, you can play them against each other to evaluate which one works best.

      {\it Hint:} Design a \java{Genius} class that extends \java{Player} and overrides the \java{play} method, and then replace one of the players with a \java{Genius} object.

      \end{exercise}
  - name: Exercise 14.3
    type: section
    chapter: Extending classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex14.3

      One limitation of the program we wrote in this chapter is that it only handles two players.
      Modify the \java{Eights} class to create an \java{ArrayList} of players, and modify \java{nextPlayer} to select the next player.

      \end{exercise}
  - name: Exercise 14.4
    type: section
    chapter: Extending classes
    section: Exercises
    before: false
    latex: |
      \begin{exercise}  %%V6 Ex14.4

      When we designed the program for this chapter, we tried to minimize the number of classes.
      As a result, we ended up with a few awkward methods.
      For example, \java{cardMatches} is a static method in \java{Player}, but it would be more natural if it were an instance method in \java{Card}.

      The problem is that \java{Card} is supposed to be useful for any card game, not just {\it Crazy Eights}.
      You can solve this problem by adding a new class, \java{EightsCard}, that extends \java{Card} and provides a method, \java{match}, that checks whether two cards match according to the rules of {\it Crazy Eights}.

      At the same time, you could create a new class, \java{EightsHand}, that extends \java{Hand} and provides a method, \java{scoreHand}, that adds up the scores of the cards in the hand.
      And while you're at it, you could add a method named \java{scoreCard} to \java{EightsCard}.

      Whether or not you actually make these changes, draw a UML class diagram that shows this alternative object hierarchy.

      \end{exercise}
